---
title: "Function Calling"
description: "Integrate external APIs and execute custom functions during conversations"
---

NavTalk supports function calling to integrate digital humans with external systems, enabling the execution of custom functions and API calls during conversations. This allows the digital human to interact with weather APIs, databases, CRM systems, IoT devices, and other external services.

<Steps>
<Step title="Define Function Tools">
Define the functions that can be called by including them in the `tools` array. In v2, session configuration (voice, model, instructions, etc.) is passed through WebSocket connection URL parameters. Tools can be configured by sending a `session.update` message with only the tools array after receiving `realtime.session.created`:

<CodeGroup>
```javascript JavaScript
const NavTalkMessageType = Object.freeze({
    REALTIME_SESSION_CREATED: "realtime.session.created",
    REALTIME_RESPONSE_FUNCTION_CALL_ARGUMENTS_DONE: "realtime.response.function_call_arguments.done",
    // ... other event types
});

// After receiving realtime.session.created, send tools configuration
async function sendToolsConfiguration() {
  const sessionConfig = {
    type: 'session.update',
    session: {
      tools: [
        {
          type: 'function',
          name: 'function_call_judge',
          description: 'Automatically triggers function extension calls when user requests exceed the current conversation capabilities.',
          parameters: {
            type: 'object',
            properties: {
              userInput: {
                type: 'string',
                description: 'Raw user request content to be processed'
              }
            },
            required: ['userInput']
          }
        }
      ]
    }
  };
  
  socket.send(JSON.stringify(sessionConfig));
}

// Call this after receiving realtime.session.created
socket.onmessage = async (event) => {
  if (typeof event.data === 'string') {
    const data = JSON.parse(event.data);
    
    if (data.type === NavTalkMessageType.REALTIME_SESSION_CREATED) {
      await sendToolsConfiguration();
    }
  }
};
```

```python Python
NAV_TALK_MESSAGE_TYPE = {
    'REALTIME_SESSION_CREATED': 'realtime.session.created',
    'REALTIME_RESPONSE_FUNCTION_CALL_ARGUMENTS_DONE': 'realtime.response.function_call_arguments.done',
    # ... other event types
}

# After receiving realtime.session.created, send tools configuration
async def send_tools_configuration(websocket):
    session_config = {
        'type': 'session.update',
        'session': {
            'tools': [
                {
                    'type': 'function',
                    'name': 'function_call_judge',
                    'description': 'Automatically triggers function extension calls when user requests exceed the current conversation capabilities.',
                    'parameters': {
                        'type': 'object',
                        'properties': {
                            'userInput': {
                                'type': 'string',
                                'description': 'Raw user request content to be processed'
                            }
                        },
                        'required': ['userInput']
                    }
                }
            ]
        }
    }
    
    await websocket.send(json.dumps(session_config))

# Call this after receiving realtime.session.created
async def handle_messages(websocket):
    async for message in websocket:
        if isinstance(message, str):
            data = json.loads(message)
            
            if data.get('type') == NAV_TALK_MESSAGE_TYPE['REALTIME_SESSION_CREATED']:
                await send_tools_configuration(websocket)
```
</CodeGroup>

<Note>
  You can define multiple functions in the `tools` array. Each function should have a unique name, clear description, and well-defined parameters. In v2, session configuration (voice, model, instructions, etc.) is passed through WebSocket connection URL parameters, not through `session.update`. Only send the `tools` array in the `session.update` message.
</Note>
</Step>

<Step title="Listen for Function Call Events">
Listen for function call events in your WebSocket message handler. When a function needs to be called, you'll receive a `realtime.response.function_call_arguments.done` event:

<CodeGroup>
```javascript JavaScript
const NavTalkMessageType = Object.freeze({
    REALTIME_RESPONSE_FUNCTION_CALL_ARGUMENTS_DONE: "realtime.response.function_call_arguments.done",
    // ... other event types
});

socket.onmessage = (event) => {
  if (typeof event.data === 'string') {
    const data = JSON.parse(event.data);
    const nav_data = data.data || data;
    
    switch (data.type) {
      case NavTalkMessageType.REALTIME_RESPONSE_FUNCTION_CALL_ARGUMENTS_DONE:
        handleFunctionCall(nav_data, data);
        break;
      
      // ... handle other message types
    }
  }
};
```

```python Python
NAV_TALK_MESSAGE_TYPE = {
    'REALTIME_RESPONSE_FUNCTION_CALL_ARGUMENTS_DONE': 'realtime.response.function_call_arguments.done',
    # ... other event types
}

async def handle_messages(websocket):
    async for message in websocket:
        if isinstance(message, str):
            data = json.loads(message)
            nav_data = data.get('data', data)
            
            if data.get('type') == NAV_TALK_MESSAGE_TYPE['REALTIME_RESPONSE_FUNCTION_CALL_ARGUMENTS_DONE']:
                await handle_function_call(nav_data, data, websocket)
            
            # ... handle other message types
```
</CodeGroup>

The `realtime.response.function_call_arguments.done` event contains the following properties:

<ResponseField name="data.arguments" type="string">
JSON string containing the function call parameters. Parse this JSON string to extract the actual parameter values.

**Example**: `"{\"userInput\": \"What's the weather in Beijing?\"}"`
</ResponseField>

<ResponseField name="data.call_id" type="string">
Unique identifier for this function call. **Required** when returning results - use this `call_id` when sending the function call output back to the AI.

**Example**: `"call-123456"`
</ResponseField>
</Step>

<Step title="Handle Function Calls">
Parse the function call arguments and execute your custom logic:

<CodeGroup>
```javascript JavaScript
function handleFunctionCall(nav_data, eventJson) {
  try {
    // Parse function arguments
    const functionCallArgs = JSON.parse(nav_data.arguments);
    const userInput = functionCallArgs.userInput;
    const callId = nav_data.call_id;
    
    if (userInput) {
      // Call your external API or business logic
      callExternalAPI(userInput)
        .then(result => {
          // Send the result back
          sendFunctionCallResult(result, callId);
        })
        .catch(error => {
          console.error('Function call failed:', error);
          // Send error result
          sendFunctionCallResult('Error: ' + error.message, callId);
        });
    } else {
      console.error('Missing required parameter: userInput');
    }
  } catch (error) {
    console.error('Error parsing function call arguments:', error);
  }
}
```

```python Python
async def handle_function_call(nav_data, event_json, websocket):
    try:
        # Parse function arguments
        function_call_args = json.loads(nav_data['arguments'])
        user_input = function_call_args.get('userInput')
        call_id = nav_data['call_id']
        
        if user_input:
            # Call your external API or business logic
            try:
                result = await call_external_api(user_input)
                # Send the result back
                await send_function_call_result(result, call_id, websocket)
            except Exception as error:
                print(f'Function call failed: {error}')
                # Send error result
                await send_function_call_result(f'Error: {str(error)}', call_id, websocket)
        else:
            print('Missing required parameter: userInput')
    except Exception as error:
        print(f'Error parsing function call arguments: {error}')
```
</CodeGroup>
</Step>

<Step title="Integrate External APIs">
Call your external APIs or backend services to handle the business logic:

<CodeGroup>
```javascript JavaScript
async function callExternalAPI(userInput) {
  return new Promise(async (resolve, reject) => {
    // Example: Call your backend API
    fetch('https://your-api.com/api/function-call', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        userInput: userInput,
        license: 'your-license-key',
        // ... other parameters
      }),
    })
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.text(); // or response.json() for JSON responses
      })
      .then(result => {
        console.log('API result:', result);
        resolve(result);
      })
      .catch(error => {
        console.error('API call error:', error);
        reject(error);
      });
  });
}

// Example: Weather API integration
async function getWeather(location) {
  const response = await fetch(`https://api.weather.com/forecast?location=${location}`);
  const data = await response.json();
  return `Weather in ${location}: ${data.condition}, ${data.temperature}°C`;
}

// Example: Knowledge base query
async function queryKnowledgeBase(query) {
  const response = await fetch('https://your-kb-api.com/search', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ query: query })
  });
  const results = await response.json();
  return results.summary || 'No results found';
}
```

```python Python
import aiohttp

async def call_external_api(user_input):
    """Call your external API or backend service"""
    async with aiohttp.ClientSession() as session:
        async with session.post(
            'https://your-api.com/api/function-call',
            json={
                'userInput': user_input,
                'license': 'your-license-key',
                # ... other parameters
            },
            headers={'Content-Type': 'application/json'}
        ) as response:
            if response.status == 200:
                result = await response.text()
                print(f'API result: {result}')
                return result
            else:
                raise Exception(f'HTTP error! status: {response.status}')

# Example: Weather API integration
async def get_weather(location):
    async with aiohttp.ClientSession() as session:
        async with session.get(f'https://api.weather.com/forecast?location={location}') as response:
            data = await response.json()
            return f"Weather in {location}: {data['condition']}, {data['temperature']}°C"

# Example: Knowledge base query
async def query_knowledge_base(query):
    async with aiohttp.ClientSession() as session:
        async with session.post(
            'https://your-kb-api.com/search',
            json={'query': query}
        ) as response:
            results = await response.json()
            return results.get('summary', 'No results found')
```
</CodeGroup>
</Step>

<Step title="Return Results to AI">
After processing the function call, send the result back to the AI so it can continue the conversation:

<CodeGroup>
```javascript JavaScript
function sendFunctionCallResult(result, callId) {
  // Send function call output
  const resultJson = {
    type: 'conversation.item.create',
    item: {
      type: 'function_call_output',
      output: result,
      call_id: callId
    }
  };
  
  socket.send(JSON.stringify(resultJson));
  console.log('Sent function call result:', resultJson);
  
  // Request AI to generate a response based on the function result
  const responseRequest = {
    type: 'response.create'
  };
  socket.send(JSON.stringify(responseRequest));
  console.log('Requested AI response');
}
```

```python Python
async def send_function_call_result(result, call_id, websocket):
    # Send function call output
    result_json = {
        'type': 'conversation.item.create',
        'item': {
            'type': 'function_call_output',
            'output': result,
            'call_id': call_id
        }
    }
    
    await websocket.send(json.dumps(result_json))
    print(f'Sent function call result: {result_json}')
    
    # Request AI to generate a response based on the function result
    response_request = {
        'type': 'response.create'
    }
    await websocket.send(json.dumps(response_request))
    print('Requested AI response')
```
</CodeGroup>

<Warning>
  Always call `response.create` after sending the function call output. This tells the AI to process the function result and continue the conversation.
</Warning>
</Step>
</Steps>

## Common Use Cases

| Use Case | Example | Implementation |
|----------|---------|----------------|
| **Weather API** | User asks: "What's the weather in Beijing?" | Call weather API with location, return forecast |
| **Knowledge Base** | User asks: "How do I integrate function calling?" | Search knowledge base, return relevant documentation |
| **Database Query** | User asks: "Show me today's sales numbers" | Query database, return formatted results |
| **IoT Control** | User says: "Turn on the lights" | Call IoT API to control devices |
| **CRM Integration** | User asks: "Update customer status for John" | Call CRM API to update records |

<Note>
  Function calling allows you to extend the digital human's capabilities beyond conversation. Integrate with any REST API, database, or backend service to create powerful, context-aware applications.
</Note>